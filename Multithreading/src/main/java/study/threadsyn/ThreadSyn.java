package study.threadsyn;

/**
 * @author AllLearnAllNothingRookie
 * @version 1.0
 * @date 2023/1/30 21:13
 * todo: 线程同步机制
 *    1.在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就需要使用同步访问技术，保证
 *      数据在任何同一时刻，最多有一个线程访问，一保证数据的完整性。
 *    2.线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存进行操作，直到
 *      该线程完成操作，其他线程才能对该内存地址进行操作
 *todo:线程同步的具体方式  - synchronized
 *  1.同步代码块
 *        synchronized (对象){ //得到对象的锁，才能操作同步代码
 *            //需要被同步的代码;
 *        }
 *  2.同步方法  -- synchronized还可以放在方法声明中，表示整个方法为同步方法
 *       public synchronized  void m(String name){
 *           //需要被同步的代码
 *       }
 *todo: 互斥锁
 *  1.Java语言中引入了对象互斥锁的概念，来保证共享数据操作的完整性
 *  2.每个对象都对应于可称为"互斥锁"的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象
 *  3.关键字 synchronized 来与对象的互斥锁联系，当某个对象用synchronized修饰时，表明该对象
 *    在任一时刻只能由一个线程访问
 *  4.同步的局限性：降低程序的执行效率
 *  5.同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)
 *  6.同步方法(静态的)锁为当前类本身,类.class
 *todo: 注意事项
 *  1.同步方法如果没有使用static修饰：默认锁对象是this
 *  2.同步方法使用static修饰：默认锁对象是 当前类.class
 *todo: 同步代码块实现步骤
 *    1.需要先分析上锁的代码
 *    2.选择同步代码块或同步方法
 *    3.要求多个线程的锁对象魏同一个即可
 *
 *todo:释放锁
 *  1.当前线程的同步方法，同步代码块执行结束
 *  2.当前线程在同步代码块，同步方法中遇到break，return
 *  3.当前线程在同步方法，同步代码块中出现了未处理的Error或Exception，导致异常结束
 *  4.当前线程在同步方法，同步代码块中执行了线程对象的wait()方法，当前线程暂停，并释放锁
 *
 * todo:下面的情况不会释放锁
 *   1.线程执行同步代码块或同步方法时，程序调用Thread.sleep(),Thread.yield()方法暂停
 *     当前线程的执行，不会释放锁
 *   2.线程执行同步代码块或同步方法时，其他线程调用了该线程的suspend()方法将该线程挂起
 *     该线程不会释放锁。
 *     提示:应尽量避免使用suspend()和resume()来控制线程，suspend()和resume()方法
 *         不再推荐使用
 */
public class ThreadSyn {

}
